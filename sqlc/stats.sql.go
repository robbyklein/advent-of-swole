// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: stats.sql

package sqlc

import (
	"context"
)

const getCaloriesStats = `-- name: GetCaloriesStats :many
SELECT 
    d.day_number,
    COALESCE(SUM(c.calories_burned_estimate)::INT, 0) AS total_calories
FROM 
    days d
LEFT JOIN 
    day_challenges dc ON d.id = dc.day_id
LEFT JOIN 
    challenges c ON dc.challenge_id = c.id
LEFT JOIN 
    user_challenge_completions ucc ON c.id = ucc.challenge_id AND d.id = ucc.day_id
WHERE 
    d.challenge_month_id = $1
    AND ucc.user_id = $2
GROUP BY 
    d.day_number
ORDER BY 
    d.day_number
`

type GetCaloriesStatsParams struct {
	ChallengeMonthID int64
	UserID           int64
}

type GetCaloriesStatsRow struct {
	DayNumber     int32
	TotalCalories interface{}
}

func (q *Queries) GetCaloriesStats(ctx context.Context, arg GetCaloriesStatsParams) ([]GetCaloriesStatsRow, error) {
	rows, err := q.db.Query(ctx, getCaloriesStats, arg.ChallengeMonthID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCaloriesStatsRow
	for rows.Next() {
		var i GetCaloriesStatsRow
		if err := rows.Scan(&i.DayNumber, &i.TotalCalories); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryStats = `-- name: GetCategoryStats :many
SELECT 
    c.category,
    COUNT(*) AS count,
    ROUND(
        (COUNT(*) * 100.0) / SUM(COUNT(*)) OVER (), 
        2
    )::FLOAT AS percentage
FROM 
    challenges c
JOIN 
    day_challenges dc 
    ON c.id = dc.challenge_id
JOIN 
    days d 
    ON dc.day_id = d.id
JOIN 
    user_challenge_completions ucc 
    ON c.id = ucc.challenge_id 
   AND d.id = ucc.day_id
WHERE 
    d.challenge_month_id = $1
    AND ucc.user_id = $2
GROUP BY 
    c.category
ORDER BY 
    percentage DESC
`

type GetCategoryStatsParams struct {
	ChallengeMonthID int64
	UserID           int64
}

type GetCategoryStatsRow struct {
	Category   string
	Count      int64
	Percentage float64
}

func (q *Queries) GetCategoryStats(ctx context.Context, arg GetCategoryStatsParams) ([]GetCategoryStatsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryStats, arg.ChallengeMonthID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoryStatsRow
	for rows.Next() {
		var i GetCategoryStatsRow
		if err := rows.Scan(&i.Category, &i.Count, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMuscleStats = `-- name: GetMuscleStats :many
SELECT 
    UNNEST(c.muscle_groups) AS muscle_group,
    COUNT(*) AS count,
    ROUND(
        (COUNT(*) * 100.0) / SUM(COUNT(*)) OVER (), 
        2
    )::FLOAT AS percentage,
    SUM(COUNT(*)) OVER ()::FLOAT AS total_count
FROM 
    challenges c
JOIN 
    day_challenges dc 
    ON c.id = dc.challenge_id
JOIN 
    days d 
    ON dc.day_id = d.id
JOIN 
    user_challenge_completions ucc 
    ON c.id = ucc.challenge_id 
   AND d.id = ucc.day_id
WHERE 
    d.challenge_month_id = $1
    AND ucc.user_id = $2
GROUP BY 
    muscle_group
ORDER BY 
    percentage DESC
`

type GetMuscleStatsParams struct {
	ChallengeMonthID int64
	UserID           int64
}

type GetMuscleStatsRow struct {
	MuscleGroup interface{}
	Count       int64
	Percentage  float64
	TotalCount  float64
}

func (q *Queries) GetMuscleStats(ctx context.Context, arg GetMuscleStatsParams) ([]GetMuscleStatsRow, error) {
	rows, err := q.db.Query(ctx, getMuscleStats, arg.ChallengeMonthID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMuscleStatsRow
	for rows.Next() {
		var i GetMuscleStatsRow
		if err := rows.Scan(
			&i.MuscleGroup,
			&i.Count,
			&i.Percentage,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalChallengesCompletedForMonth = `-- name: GetTotalChallengesCompletedForMonth :one
SELECT 
    COUNT(*) AS total_challenges_completed
FROM 
    user_challenge_completions ucc
JOIN 
    days d ON ucc.day_id = d.id
WHERE 
    d.challenge_month_id = $1
    AND ucc.user_id = $2
`

type GetTotalChallengesCompletedForMonthParams struct {
	ChallengeMonthID int64
	UserID           int64
}

func (q *Queries) GetTotalChallengesCompletedForMonth(ctx context.Context, arg GetTotalChallengesCompletedForMonthParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalChallengesCompletedForMonth, arg.ChallengeMonthID, arg.UserID)
	var total_challenges_completed int64
	err := row.Scan(&total_challenges_completed)
	return total_challenges_completed, err
}

const getTotalParticipantsForMonth = `-- name: GetTotalParticipantsForMonth :one
SELECT 
    COUNT(DISTINCT ucc.user_id) AS total_participants
FROM 
    user_challenge_completions ucc
JOIN 
    days d ON ucc.day_id = d.id
WHERE 
    d.challenge_month_id = $1
`

func (q *Queries) GetTotalParticipantsForMonth(ctx context.Context, challengeMonthID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalParticipantsForMonth, challengeMonthID)
	var total_participants int64
	err := row.Scan(&total_participants)
	return total_participants, err
}

const getUserRankForMonth = `-- name: GetUserRankForMonth :one
WITH leaderboard AS (
    SELECT 
        u.id AS user_id,
        COALESCE(SUM(c.points), 0) AS total_points
    FROM 
        users u
    LEFT JOIN 
        user_challenge_completions ucc ON u.id = ucc.user_id
    LEFT JOIN 
        challenges c ON ucc.challenge_id = c.id
    LEFT JOIN 
        days d ON ucc.day_id = d.id
    WHERE 
        d.challenge_month_id = $1
    GROUP BY 
        u.id
    ORDER BY 
        total_points DESC
)
SELECT 
    RANK() OVER (ORDER BY total_points DESC) AS rank
FROM 
    leaderboard
WHERE 
    user_id = $2
`

type GetUserRankForMonthParams struct {
	ChallengeMonthID int64
	UserID           int64
}

func (q *Queries) GetUserRankForMonth(ctx context.Context, arg GetUserRankForMonthParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUserRankForMonth, arg.ChallengeMonthID, arg.UserID)
	var rank int64
	err := row.Scan(&rank)
	return rank, err
}
